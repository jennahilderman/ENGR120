#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  straightButton, sensorTouch)
#pragma config(Sensor, dgtl2,  turnButton,     sensorTouch)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define part 1

const   int rotate = 90;
const   int meterForward = 3000;
const   int movingSpeed = 20;
const		int turningSpeed = 20;
const		int openClawSpeed = 30;
const		int openClawDistance = 40;

bool straightButton_pushed;
bool turnButton_pushed;

enum	t_motion{
	arret = 0,
	straight,
	left,
	right,
};

enum t_claw{
	neutral = 0,
	open,
	close,
};

t_claw claw;
t_motion motion;

void monitorInput(){
    if(SensorValue(straightButton) && !straightButton_pushed){
        straightButton_pushed = true;
    }
    if(SensorValue(turnButton) && !turnButton_pushed){
        turnButton_pushed = true;
    }
}

void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

void goStraight(){
		resetMotorEncoder(speedMotorL);
		while(getMotorEncoder(speedMotorL) <= meterForward){
    motor[speedMotorR] = movingSpeed;
    motor[speedMotorL] = movingSpeed;
  }
  halt();
}
/*
void goLeft(){
	resetMotorEncoder(speedMotorL);
	motor[speedMotorR] = turningSpeed;
	motor[speedMotorL] = -turningSpeed;
	if (getMotorEncoder(speedMotorL) <= rotate){
  	halt;
  }
}
*/
void goRight(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) <= rotate){
		motor[speedMotorR] = -turningSpeed;
		motor[speedMotorL] = turningSpeed;
	}
  halt();
}

void drop(){
	resetMotorEncoder(clawMotor);
	straightButton_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}

void part_1(){
	motion = arret;
	while (true){
		monitorInput();
		switch(motion){
			case(arret):
				halt();
				if ( straightButton_pushed ) {
        	motion = straight;
        }
        // When the button that makes it turn is pushed
        if (turnButton_pushed){
        // Change to the right state
        	motion = right;
        }
        break;
			case(straight):
        // Clear flag to indicate button processed.
        straightButton_pushed = false;
				goStraight();
				motion = arret;
				break;
			case(right):
				// Clear flag to indicate button processed
        turnButton_pushed = false;
				goRight();
				motion = arret;
				break;
		}
	}
}

void part_2(){
	while(true){
		monitorInput();
		switch (claw){
		case(neutral):
			motor[clawMotor] = 0;
			if (straightButton_pushed ){
				claw = open;
			}
			break;
		case(open):
			straightButton_pushed = false;
			drop();
			claw = neutral;
			break;
		}
	}
}

task main()
{
    straightButton_pushed = turnButton_pushed = false;
    switch (part){
        case 1:
            part_1();
            break;
        case 2:
            part_2();
            break;
        default: //should never get here.
    } // end switch

}// end main
