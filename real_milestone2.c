#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  straightButton, sensorTouch)
#pragma config(Sensor, dgtl2,  turnButton,     sensorTouch)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Part 1 is the movement part
// Part 2 is to make the connection
#define part 1
// Some constants
const   int rotate = 90;
const   int meterForward = 3000;
const   int movingSpeed = 20;
const		int turningSpeed = 20;
const		int openClawSpeed = 30;
const		int openClawDistance = 40;

// Booleon statements for each button
bool straightButton_pushed;
bool turnButton_pushed;

// An enumeration describing the movement of the robot
enum	t_motion{
	arret = 0,
	straight,
	left,
	right,
};

// and enumeration describing the movement of the claw
enum t_claw{
	neutral = 0,
	open,
	close,
};

// initializing a variable of each enumeration
t_claw claw;
t_motion motion;

// A function to change the button_pushed to true when they are pushed.
void monitorInput(){
    if(SensorValue(straightButton) && !straightButton_pushed){
        straightButton_pushed = true;
    }
    if(SensorValue(turnButton) && !turnButton_pushed){
        turnButton_pushed = true;
    }
}

// Stopping the motor
void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

// Turning the motor on to go straight for over a meter
void goStraight(){
		resetMotorEncoder(speedMotorL);
		while(getMotorEncoder(speedMotorL) <= meterForward){
    motor[speedMotorR] = movingSpeed;
    motor[speedMotorL] = movingSpeed;
  }
  halt();
}
// A function that turns the robot to the left
/*
void goLeft(){
	resetMotorEncoder(speedMotorL);
	motor[speedMotorR] = turningSpeed;
	motor[speedMotorL] = -turningSpeed;
	if (getMotorEncoder(speedMotorL) <= rotate){
  	halt;
  }
}
*/
// A function that turns the robot to the right
void goRight(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) <= rotate){
		motor[speedMotorR] = -turningSpeed;
		motor[speedMotorL] = turningSpeed;
	}
  halt();
}

// A function that opens the claw
void drop(){
	resetMotorEncoder(clawMotor);
	straightButton_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}

/* 
Part 1 is a function that when the straight button is pushed makes the robot go straight
and when the turn button is pushed turns the robot 90 degrees to the right.
*/
void part_1(){
	//robot is still to start
	motion = arret;
	while (true){
		//checks to see if a button is pushed
		monitorInput();
		// start of the switch statement
		switch(motion){
			// First case is when the robot is still
			case(arret):
				halt();
				// If the straight button is pushed 
				if ( straightButton_pushed ) {
					// Change to the straight case
        			motion = straight;
        		}
        		// If the turn button is pushed
       			 if (turnButton_pushed){
        			// Change to the right state
        			motion = right;
       			}
				// Break out of the switch statement.
        		break;
			// Seccond case is if the robot is moving straight forward.
			case(straight):
        		// Clear flag to indicate button processed.
        		straightButton_pushed = false;
				// Call the go straight function to turn on both motors
				goStraight();
				// Change to the stopped state
				motion = arret;
				// Break out of the switch statement.
				break;
			// Third state is when the robot is turning.
			case(right):
				// Clear flag to indicate button processed
        		turnButton_pushed = false;
				// Call the go right statement to turn the robot 90 degrees to the right.
				goRight();
				// Change to the stopped state.
				motion = arret;
				// Break out of the switch statement.
				break;
			// End of switch statement
		}
	}
}

/*
Part 2 is to open the claw when the straight button is pushed.
*/

void part_2(){
	while(true){
		// Call the monitor input function to see if a button is pushed
		monitorInput();
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				// If the straight button is pushed
				if ( straightButton_pushed ){
					// Change to the open state
					claw = open;
				}
				// Break out of the switch statement.
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Clear flag to indicate button processed
				straightButton_pushed = false;
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = neutral;
				// Break out of the switch statement.
				break;
		}
	}
}

task main(){
	// Set both buttons to false
    straightButton_pushed = turnButton_pushed = false;
	// Start of switch statement
    switch (part){
		// If part is set to 1
        case 1:
			// Call part 1 to make the robot be able to move forward and turn
            part_1();
			// Break out of the switch statement.
            break;
		// If part is set to 2
        case 2:
			// Call part 2 to make the robot be able to open the claw.
            part_2();
			// Break out of the switch statement.
            break;
	// end switch
    }

}// end main
