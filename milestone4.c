#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraFront,     sensorReflection)
#pragma config(Sensor, in2,    infraRight,     sensorReflection)
#pragma config(Sensor, in3,    infraLeft,      sensorReflection)
#pragma config(Sensor, dgtl1,  tooFarLED,      sensorDigitalOut)
#pragma config(Sensor, dgtl5,  justRightLED,   sensorDigitalOut)
#pragma config(Sensor, dgtl6,  tooCloseLED,    sensorDigitalOut)
#pragma config(Sensor, dgtl7,  button,         sensorTouch)
#pragma config(Sensor, dgtl8,  switchRight,    sensorTouch)
#pragma config(Sensor, dgtl9,  switchLeft,     sensorTouch)
#pragma config(Sensor, dgtl11, batInput,       sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Some important constants
// How far it should back up
const		int retreat = -50;
// How fast it should move forward
const       int movingSpeed = 30;
// How fast it should turn
const		int turningSpeed = 20;
// How fast the claw should open
const		int openClawSpeed = 30;
// How far the claw should open
const		int openClawDistance = 180;
// What the ultrasonic range finder reads when it isnt finding anything
const       int tooFar = -1;
// how far away the robot should be from the beacon to make the connection
const       int justRight = 75;
// Set the LED to this to turn it off
const       int LIGHT_OFF = 0;
// Set the LED to this to turn it on
const       int LIGHT_ON = 1;
// The distance away from a wall to turn away from it
const		int wallDistance = 200;
// how far it should turn
const		int rotate = 100;
// IR difference
const		int difference = 300;
// the speed difference between motors
const		int speedDifference = movingSpeed/6;


//declaring button_pushed to be  boolean
bool    button_pushed;
bool	right_pushed;
bool	left_pushed;

// an enumeration for the position of the robot
enum t_position {
    straight = 0,
    found,
	lost,
    right,
    left,
    stopped,
    started
};

//an enumeration for the claw
enum t_claw{
	neutral = 0,
	open,
	close,
	backup,
};

// Initialize the enumerations
t_position position;
t_claw claw;
int count;
int done;
int init;

// Function to see if a button is pushed.
void monitorInput(){
    if(SensorValue(button) && !button_pushed){
        button_pushed = true;
    }
	if(SensorValue(switchRight) && !right_pushed){
		right_pushed = true;
	}
	if(SensorValue(switchLeft) && !left_pushed){
		left_pushed = true;
	}
}


// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorMiddleLight(){
	static int minLevelIR1 = 1200;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[infraFront];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 1200;
		clearTimer(T1);

		}
	else {
		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
		}
		else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}
	return(diffLevelIR1);
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorRightLight(){
	static int minLevelIR2 = 1200;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR2 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR2 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel2 = SensorValue[infraRight];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR2 = maxLevelIR2 - minLevelIR2;

		// Reset calculation for next 100 msecs.
		maxLevelIR2 = 0;
		minLevelIR2 = 1200;
		clearTimer(T1);

		}
	else {
		// Check for new minimum/maximum light levels.
		if ( lightLevel2 < minLevelIR2 ) {
			minLevelIR2 = lightLevel2;
		}
		else if ( lightLevel2 > maxLevelIR2 ) {
			maxLevelIR2 = lightLevel2;
		}
	}
	return(diffLevelIR2);
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLeftLight(){
	static int minLevelIR3 = 1200;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR3 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR3 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel3 = SensorValue[infraLeft];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR3 = maxLevelIR3 - minLevelIR3;

		// Reset calculation for next 100 msecs.
		maxLevelIR3 = 0;
		minLevelIR3 = 1200;
		clearTimer(T1);

		}
	else {
		// Check for new minimum/maximum light levels.
		if ( lightLevel3 < minLevelIR3 ) {
			minLevelIR3 = lightLevel3;
		}
		else if ( lightLevel3 > maxLevelIR3 ) {
			maxLevelIR3 = lightLevel3;
		}
	}
	return(diffLevelIR3);
}
// The finction that finds the position of the robot in relation to the beacon and the walls of the arena
int findPosition(){

	// If the front IR reading is in the IR sensor threshold
	if ( monitorMiddleLight() >= difference ){
		// Set position to found
		if (position != started){
			position = found;
			return 0;
		}
		//return 0
		return 0;
	}
	// If the front IR reading is out the IR sensor threshold and the back IR reading is out the IR sensor threshold but the ultrasonic range finder notices a wall
	if ( (monitorMiddleLight() < difference && SensorValue[batInput] <= wallDistance) || right_pushed ){
		//Set position to wall
		if (position != started){
		position = left;
		right_pushed = false;
		return 1;
	}
		//return 1
		right_pushed = false;
		return 1;
	}

	if(left_pushed){
		if(position != started){
			position = right;
			left_pushed = false;
			return 2;
		}
		left_pushed = false;
		return 2;
	}

	// If the front IR reading is out the IR sensor threshold and the back IR reading is out the IR sensor threshold but the ultrasonic range finder does not notices a wall
	if ( monitorMiddleLight() < difference && (SensorValue[batInput] >= wallDistance || SensorValue[batInput] == tooFar)){
		//Set position to straight
		if (position != started){
			position = straight;
			return 3;
		}
		//return 3
		return 3;
	}
	//Should never get here
	return 4;
}

// function to stop the motors
void halt(){
	//turn off right motor
    motor[speedMotorR] = 0;
	//turn off left motor
    motor[speedMotorL] = 0;
}

// function to reverse the robot
void goBack(){
	// turn the right motor on and subtract 6 so the right and left go the same speed
    motor[speedMotorR] = movingSpeed-speedDifference;
	//turn the left motor on
    motor[speedMotorL] = -movingSpeed;
}

// A function that starts the motor on to go straight
void goStraight(){
	// turn right motor on +6 to make the right and  left go the same speed
    motor[speedMotorR] = -movingSpeed+speedDifference;
	// turn left motor on
    motor[speedMotorL] = movingSpeed;
}

// A function that turn the robot to the left
void goLeft(){
	//turn on the right motor
	motor[speedMotorR] = -turningSpeed;
	// turn on the left motor
	motor[speedMotorL] = -turningSpeed;
}

// A function that turns the robot to the right
void goRight(){
	// turn on the right motor
	motor[speedMotorR] = turningSpeed;
	// turn on the left motor
	motor[speedMotorL] = turningSpeed;
}


// function to drop the cable
void drop(){
	// reset the claw encoder
	resetMotorEncoder(clawMotor);
	// while the encoder is less then the open claw distance
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		// turn on the claw motor
		motor[clawMotor] = -openClawSpeed;
	}
	// set claw to neutral
	motor[clawMotor] = 0;
	claw = neutral;
}


// function to make the connection
void connection(){
	while(position == found){
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				halt();
				// If the straight button is pushed
				if(SensorValue[batInput] <= justRight){
					claw = open;
				}
				// Break out of the switch statement.
				else{
					done = 1;
					button_pushed = false;
					position = started;
				}
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = backup;
				// Break out of the switch statement.
				break;
			case(backup):
				// turn off the motor before backing up
				motor[clawMotor] = 0;
				wait1Msec(2000);
				// call the go back function to move backwards
				resetMotorEncoder(speedMotorL);
				//while the encoder is greater then retreat so it only backs up a little
				while(getMotorEncoder(speedMotorL) >= (5*retreat)){
					goBack();
  				}
  				// stop the motor
  				halt();
				// turn the too close LED on
				SensorValue[tooCloseLED] = LIGHT_ON;
				// turn the just right LED on
        		SensorValue[justRightLED] = LIGHT_ON;
				// turn the too far LED on
        		SensorValue[tooFarLED] = LIGHT_ON;
				wait1Msec(1000);
				while(getMotorEncoder(clawMotor) > 0){
					motor[clawMotor] = openClawSpeed;
				}
				motor[clawMotor] = 0;
				wait1Msec(5000);
				//turn the too close LED off
				SensorValue[tooCloseLED] = LIGHT_OFF;
				// turn the just right LED off
        		SensorValue[justRightLED] = LIGHT_OFF;
				// turn the too far LED off
        		SensorValue[tooFarLED] = LIGHT_OFF;
				// set claw to neutral
				while(getMotorEncoder(clawMotor) > 0){
					motor[clawMotor] = openClawSpeed;
				}
				motor[clawMotor] = 0;
				claw = neutral;
				// break out of the switch statement
				break;
		}
		if(done == 1){
			done = 0;
			//position = started;
			//break;
		}
		//end of switch statement
	}
	//end of while loop
}

void lightLED(){
		//Checks to see if the robot is facing the beacon but too far away
    if(SensorValue(batInput) > justRight && monitorMiddleLight() >= difference ){
		// turn the too far LED on
        SensorValue[tooFarLED] = LIGHT_ON;
		// turn the just right LED off
        SensorValue[justRightLED] = LIGHT_OFF;
		// turn the too close LED off
        SensorValue[tooCloseLED] = LIGHT_OFF;
    }
    // Checks to see if the robot is facing the beacon and is the proper distance away
    else if(SensorValue(batInput) <= justRight && monitorMiddleLight() >= difference ){
		// turn the just right LED on
        SensorValue[justRightLED] = LIGHT_ON;
		// turn the too close LED off
        SensorValue[tooCloseLED] = LIGHT_OFF;
		// turn the too far LED off
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
    else{
		// turn the too close LED off
        SensorValue[tooCloseLED] = LIGHT_OFF;
		// turn the just right LED off
        SensorValue[justRightLED] = LIGHT_OFF;
		// turn the too far LED off
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
}


task main()
{
	// Start
	// Set button_ pushed to false
	button_pushed = false;
	// Set position to started
    position = started;
	// Start of while
    while (true){
		// Check to see if the button is pushed
    	monitorInput();
		monitorMiddleLight();
		lightLED();
		// Start of switch
        switch(position){

            // The started case
            case(started):
                // Stop the motor
                halt();
				init = 0;
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
				monitorInput();
                // When the button is pushed switch state
                if ( button_pushed ) {
                    // If button pushed, change state
						// While the IR sensors are not sencing anything and the encoder is less then 400
                		while(monitorMiddleLight() < difference && getMotorEncoder(speedMotorL) >= -400){
                			// Turn the robot to the right
							goLeft();
                		}
						// Stop the motor
                		halt();
						//Change the position to stopped
                		position = stopped;
						//find the actual position
                		findPosition();
                    // Clear flag to indicate button processed.
                    button_pushed = false;
                }
			//break out of the started case
            break;

			//The stopped case
            case(stopped):
				// stop the motor
            	halt();
            	// Reset the encoders
            	resetMotorEncoder(clawMotor);
            	resetMotorEncoder(speedMotorL);
				//find the position
            	findPosition();
			// break out of the stopped case
            break;

			// The straight case
            case(straight):
            	// Reset the encoder
				resetMotorEncoder(speedMotorL);
				//While there there is no wall of beacon sensed
            	while((SensorValue(batInput) >= wallDistance || SensorValue(batInput) == tooFar) && (!left_pushed && !right_pushed)) {
					monitorInput();
					monitorMiddleLight();
					//Go straight
                    goStraight();
                	}
				// Find the position
                findPosition();
			// Break out of the straight case
            break;

			//The found case
            case(found):
				//While the beacon is too far away
				init = monitorMiddleLight();
              	while((SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar) &&  (monitorMiddleLight() >= difference && !left_pushed && !right_pushed)){
					monitorInput();
					monitorMiddleLight();
					monitorLeftLight();
					monitorRightLight();
					if(monitorMiddleLight() >= init){
					// go straight
            	    goStraight();
					}
					if(monitorMiddleLight() < init){
						position = lost;
					}
          		}
          		halt();
				resetMotorEncoder(speedMotorL);
				// If the front IR sensor is still within the threshold
				monitorMiddleLight();
				monitorLeftLight();
				monitorRightLight();
				if((left_pushed && monitorMiddleLight() >= difference) || (.5*monitorLeftLight() >= monitorRightLight() && SensorValue[batInput] <= wallDistance) ){
					resetMotorEncoder(speedMotorL);
                	while(getMotorEncoder(speedMotorL) >= retreat){
						goBack();
  					}
  					// stop the motor
  					halt();
                	wait1Msec(1000);
					//go left
                	resetMotorEncoder(speedMotorL);
					// while the robot is not facing the beacon and only rotates up to the rotate constant
    				while(getMotorEncoder(speedMotorL) >= -rotate/5){
						//turn left
						goLeft();
					}
					left_pushed = false;
					right_pushed = false;
					position = lost;
					break;
				}
				monitorMiddleLight();
				monitorLeftLight();
				monitorRightLight();
				if(right_pushed && monitorMiddleLight() >= difference || (.5*monitorRightLight() >= monitorRightLight() && SensorValue[batInput] <= wallDistance)){
					resetMotorEncoder(speedMotorL);
                	while(getMotorEncoder(speedMotorL) >= retreat){
						goBack();
  					}
  					// stop the motor
  					halt();
                	wait1Msec(1000);
					//go left
                	resetMotorEncoder(speedMotorL);
					// while the robot is not facing the beacon and only rotates up to the rotate constant
    				while(getMotorEncoder(speedMotorL) <= rotate/5){
						//turn left
						goRight();
					}
					left_pushed = false;
					right_pushed = false;
					position = lost;
					break;
				}
				if (monitorMiddleLight() < difference && (SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar )){
					position = lost;
					break;
				}
				if (SensorValue(batInput) <= justRight && monitorMiddleLight() >= difference){
					//Wait a few seconds
                	// wait1Msec(1000);
					// findThePerfectSpot();
					wait1Msec(1000);
					//Make the connection
					connection();
					button_pushed = false;
					right_pushed = false;
					left_pushed = false;
					break;
              	}
				findPosition();
				// break out of the found case
                break;

				//The lost case
				case(lost):
					monitorInput();
					monitorMiddleLight();
					//Reset the left motor encoder
					resetMotorEncoder(speedMotorL);
					//while the front IR sensor does not see the beacon
					count = 0;
					while (monitorMiddleLight() < difference ){
						//While the encoder is greater or equal to -50
						while(getMotorEncoder(speedMotorL) >= -20-(20*count) && monitorMiddleLight() < difference ){
							//Go left
							goLeft();
						}
						//Check to the right
						while(getMotorEncoder(speedMotorL) <= 20+(20*count) && monitorMiddleLight() < difference){
							//Go right
							goRight();
						}
						count++;
					}
					if (monitorMiddleLight() >= difference){
						position = found;
					}
					else{
						findPosition();
					}
				break;

				//The wall case
                case(left):
					//Backup a little
					resetMotorEncoder(speedMotorL);
                	while(getMotorEncoder(speedMotorL) >= retreat){
						goBack();
  					}
  					// stop the motor
  					halt();
                	wait1Msec(1000);
					//go left
                	resetMotorEncoder(speedMotorL);
					// while the robot is not facing the beacon and only rotates up to the rotate constant
    				while(monitorMiddleLight() < difference && getMotorEncoder(speedMotorL) >= -rotate){
						//turn left
						goLeft();
					}
					// turn off the motors
  					halt();
  					wait1Msec(1000);
					//find position
  					right_pushed = false;
  					left_pushed = false;
                	findPosition();
				// break out of the wall case
                break;

				//The wall case
                case(right):
					monitorInput();
					monitorMiddleLight();
					//Backup a little
					resetMotorEncoder(speedMotorL);
                	while(getMotorEncoder(speedMotorL) >= retreat){
						goBack();
  					}
  					// stop the motor
  					halt();
                	wait1Msec(1000);
					//go left
                	resetMotorEncoder(speedMotorL);
					// while the robot is not facing the beacon and only rotates up to the rotate constant
    				while(monitorMiddleLight() < difference && getMotorEncoder(speedMotorL) <= rotate){
						//turn left
						goRight();
					}
					left_pushed = false;
					right_pushed = false;
					// turn off the motors
  					halt();
  					wait1Msec(1000);
					//find position
                	findPosition();
				// break out of the wall case
                break;

		}
	}
}
