#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraFrontR,    sensorReflection)
#pragma config(Sensor, in2,    infraFrontL,    sensorReflection)
#pragma config(Sensor, in3,    infraRight,     sensorReflection)
#pragma config(Sensor, in4,    infraLeft,      sensorReflection)
#pragma config(Sensor, in5,    infraBack,      sensorReflection)
#pragma config(Sensor, dgtl1,  button, sensorTouch)
#pragma config(Sensor, dgtl2,  batInput,       sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const		int retreat = -50;
const       int rotate = 100;
const       int movingSpeed = 30;
const		int turningSpeed = 20;
const		int openClawSpeed = 30;
const		int openClawDistance = 40;
const       int tooFar = -1;
const       int justRight = 7;
const		int IR_SENSOR_THRESHOLD = 830;

bool    button_pushed;

// An enumeration for what direction the wheels are facing.
/*
enum t_wheelState {
    straight = 0,
    left,
    right,
    stop
};
*/
// An enumeration for what position the robot is in.
enum t_position {
    straight = 0,
    left,
    right,
    back,
    stop
};

enum t_claw{
	neutral = 0,
	open,
	close,
	backup,
};


// Initialize the enumerations
t_position position;
t_wheelState wheelState;
t_claw claw;


// Function to see if a button is pushed.
void monitorInput(){
    if(SensorValue(button) && !button_pushed){
        button_pushed = true;
    }
}

// You guys can ignore this function
// Function finds the position of the robot
int findPosition(){
    if ((SensorValue[infraFrontR] <= (0.7*SensorValue[infraFrontL]) || SensorValue[infraFrontL] <= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        position = straight;
        wheelState = straight;
        return 0;
        }
    if ((SensorValue[infraFrontL] >= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        position = right;
        wheelState = right;
        return 1;
    }
    if ((SensorValue[infraFrontR] >= (0.7*SensorValue[infraFrontL])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){
        position = left;
        wheelState = left;
        return 2;
    }
    if (SensorValue[infraRight] < IR_SENSOR_THRESHOLD){
        position = right;
        wheelState = right;
        return 1;
        }
    if (SensorValue[infraLeft] < IR_SENSOR_THRESHOLD){
        position = left;
        wheelState = left;
        return 2;
        }
    if (SensorValue[infraBack] < IR_SENSOR_THRESHOLD){
        position = back;
        wheelState = left;
        return 3;
        }
    else{
        position = straight;
        wheelState = straight;
        return 4;
    }


}

// Stopping the motor
void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

// Turning the motor on to go straight for over a meter
void goStraight(){
	resetMotorEncoder(speedMotorL);
	while(SensorValue(batInput) > justRight || SensorValue(batInput) == tooFar){
        motor[speedMotorR] = movingSpeed-6;
        motor[speedMotorL] = movingSpeed;

    }
    halt();
}

void goBack(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) >= retreat){
        motor[speedMotorR] = -movingSpeed+6;
        motor[speedMotorL] = -movingSpeed;
  }
  halt();
}

// A function that turns the robot to the left

void goLeft(){
	resetMotorEncoder(speedMotorL);
    while(findPosition() != 0 || getMotorEncoder(speedMotorL) >= rotate){
	    motor[speedMotorR] = turningSpeed;
	    motor[speedMotorL] = -turningSpeed;
    }
  	halt();
}

// A function that turns the robot to the right
void goRight(){
	resetMotorEncoder(speedMotorL);
	while(findPosition() != 0 || getMotorEncoder(speedMotorL) <= rotate){
		motor[speedMotorR] = -turningSpeed;
		motor[speedMotorL] = turningSpeed; 
	}
  halt();
}

// A function that opens the claw
void drop(){
	resetMotorEncoder(clawMotor);
	button_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}


void useIRSensors(){
    // Start
    wheelState = stop;
    while (true){
        switch(position){
            // Start of switch
            case(stop):
                // Stop the motor
                halt();
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
                // When the button is pushed switch state
                if ( button_pushed ) {
                    // If button pushed, change state
                    findPosition();
                    // Clear flag to indicate button processed.
                    button_pushed = false;
                }
                break;

            case(straight):
                // When the robot if facing straight
                while(SensorValue(batInput) > justRight || SensorValue(batInput)){
                    goStraight();
                }
                // When the robot has moved a meter switched to the stopped state.
                    position = stop;
                break;

            case(right):
                // Turn the wheels to the right
                goRight();
                findPosition();
                break;

            case(left):
                // Turn the wheels to the left
                goLeft();
                findPosition();
                break;

            case(back):
                // Turn the wheels to the left
                goLeft();
                findPosition();
                break;
            // End of switch
        }
    }
}

void connection(){
	while(true){
		// Call the monitor input function to see if a button is pushed
		monitorInput();
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				// If the straight button is pushed
				if ( button_pushed ){
					// Change to the open state
					claw = open;
				}
				// Break out of the switch statement.
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Clear flag to indicate button processed
				button_pushed = false;
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = backup;
				// Break out of the switch statement.
				break;
			case(backup):
				motor[clawMotor] = 0;
				goBack();
				claw = neutral;
				break;
		}
	}
}

task main()
{
useIRSensors();
connection();
}
