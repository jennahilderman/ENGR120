#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraFrontL,    sensorReflection)
#pragma config(Sensor, in2,    infraBack,      sensorReflection)
#pragma config(Sensor, in3,    infraFrontR,    sensorReflection)
#pragma config(Sensor, dgtl4,  button, sensorTouch)
#pragma config(Sensor, dgtl5,  batInput,       sensorSONAR_cm)
#pragma config(Sensor, dgtl1,  tooFarLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  justRightLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  tooCloseLED,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Some important constants
const				int retreat = -50;
const       int rotate = 100;
const       int movingSpeed = 30;
const				int turningSpeed = 20;
const				int openClawSpeed = 30;
const				int openClawDistance = 40;
const       int tooFar = -1;
const       int justRight = 7;
const				int IR_SENSOR_THRESHOLD = 500;
const       int LIGHT_OFF = 0;
const       int LIGHT_ON = 1;
const				int wallDistance = 12;

//declaring button_pushed to be  boolean
bool    button_pushed;

// an enumeration for the position of the robot
enum t_position {
    straight = 0,
    left,
    right,
    wall,
    tooClose,
    stopped,
    started
};

//an enumeration for the claw
enum t_claw{
	neutral = 0,
	open,
	close,
	backup,
};



// Initialize the enumerations
t_position position;
t_claw claw;
int number;


// Function to see if a button is pushed.
void monitorInput(){
    if(SensorValue(button) && !button_pushed){
        button_pushed = true;
    }
}

// Function finds the position of the robot
void findPosition(){
		// If the front right IR is less or equal to 70% of the front left IR or vice versa and both are in the IR sensor threshold then the robot should go straight
    if (((SensorValue[infraFrontR] <= (0.7*SensorValue[infraFrontL])) || (SensorValue[infraFrontL] <= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD)){
      //Set position to straight
    	position = straight;
        }
    // If the front left IR  is greater then 70% of the front right IR and the Right IR is within the IR threshhold the robot should turn right
    if ((SensorValue[infraFrontL] >= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
    		// Set position to right
        position = right;
    }
    // If the front right IR is greater the 70% of the front left IR and the left IR is within the IR threshold the robot should turn left.
    if ((SensorValue[infraFrontR] >= (0.7*SensorValue[infraFrontL])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){
        // Set the position to left
    		position = left;
    }
    // If the back IR is within the threshold
    if (SensorValue[infraBack] < IR_SENSOR_THRESHOLD){
    		// Set the position to left
        position = left;
        }
    // If none of the IR sensors are withing the IR threshold and the ultra sonic range finder shows that there is a wall in fron of it it should turn
    if (SensorValue[infraFrontR] > IR_SENSOR_THRESHOLD && SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && SensorValue[infraBack] > IR_SENSOR_THRESHOLD && SensorValue(batInput) <= wallDistance && SensorValue(batInput) != tooFar ){
        // Set the position to wall
    		position = wall;
    }
    // Else set position to straight
    position = straight;
}
// a function that gives a number for each of the robots positions
int positionNumber(){
		// If the front right IR is less or equal to 70% of the front left IR or vice versa and both are in the IR sensor threshold then the position number is 0.
    if ((SensorValue[infraFrontR] <= (0.7*SensorValue[infraFrontL]) || SensorValue[infraFrontL] <= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        // return 0
    		return 0;
    }
    // If the front left IR  is greater then 70% of the front right IR and the Right IR is within the IR threshhold the position number is 1
    if ((SensorValue[infraFrontL] >= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        //return 1
    		return 1;
    }
    // If none of the IR sensors are withing the IR threshold and the ultra sonic range finder shows that there is a wall in front of it set the posotion number to 2
    if ((SensorValue[infraFrontR] >= (0.7*SensorValue[infraFrontL])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){
        //return 2
    		return 2;
    }
    if (SensorValue[infraBack] < IR_SENSOR_THRESHOLD){
        return 2;
        }
    if (SensorValue[infraFrontR] > IR_SENSOR_THRESHOLD && SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && SensorValue[infraBack] > IR_SENSOR_THRESHOLD && SensorValue(batInput) <= wallDistance && SensorValue(batInput) != tooFar ){
        return 3;
    }
    return 4;
}

// Stopping the motor
void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

// Turning the motor on to go straight until it his a wall of the beacon
void goStraight(){
	resetMotorEncoder(speedMotorL);
	while(SensorValue(batInput) > justRight || SensorValue(batInput) == tooFar){
        motor[speedMotorR] = -movingSpeed+6;
        motor[speedMotorL] = movingSpeed;
    }
    halt();
}

// a function to make the robot move backwards
void goBack(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) >= retreat){
        motor[speedMotorR] = movingSpeed-6;
        motor[speedMotorL] = -movingSpeed;
  }
  halt();
}

// A function that turns the robot to the left
void goLeft(){
		resetMotorEncoder(speedMotorL);
    while(positionNumber() != 0 && getMotorEncoder(speedMotorL) >= -rotate){
	    motor[speedMotorR] = -turningSpeed;
	    motor[speedMotorL] = -turningSpeed;
    }
  	halt();
}

// A function that turns the robot to the right
void goRight(){
	resetMotorEncoder(speedMotorL);
	while(positionNumber() != 0 && getMotorEncoder(speedMotorL) >= rotate){
		motor[speedMotorR] = turningSpeed;
		motor[speedMotorL] = turningSpeed;
	}
  halt();
}

// A function that opens the claw
void drop(){
	resetMotorEncoder(clawMotor);
	button_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}


void connection(){
	while(true){
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				// If the straight button is pushed
				if ( button_pushed ){
					// Change to the open state
					claw = open;
				}
				// Break out of the switch statement.
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Clear flag to indicate button processed
				button_pushed = false;
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = backup;
				// Break out of the switch statement.
				break;
			case(backup):
				// turn off the motor before backing up
				motor[clawMotor] = 0;
				// call the go back function to move backwards
				goBack();
				// set claw to neutral
				claw = neutral;
				// break out of the switch statement
				break;
		}
		//end of switch statement
	}
	//end of while loop
}


//A function that tells which LEDs to light up
void lightLED(){
		//set number to be the position number
		number = positionNumber();
		//Checks to see if the robot is facing the beacon but too far away
    if(SensorValue(batInput) > justRight && number == 0){
        SensorValue[tooFarLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooCloseLED] = LIGHT_OFF;
    }
    // Checks to see if the robot is facing the beacon and is the proper distance away
    else if(SensorValue(batInput) == justRight && number == 0){
        SensorValue[justRightLED] = LIGHT_ON;
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
        connection();
    }
    // Checks to see if the robot is facing the beacon and is too close to the beacon
    else if(SensorValue(batInput) < justRight && number == 0){
        SensorValue[tooCloseLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
    // if none of the other
    else{
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }

}


task main()
{
    // Start
	button_pushed = false;
    position = started;
    while (true){
    		monitorInput();
        switch(position){
            // Start of switch
            case(started):
                // Stop the motor
                halt();
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
                // When the button is pushed switch state
                if ( button_pushed ) {
                    // If button pushed, change state
                    findPosition();
                    // Clear flag to indicate button processed.
                    //button_pushed = false;
                }
                lightLED();
                break;
            case(stopped):
            		halt();
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
                lightLED();
                findPosition();
                break;
            case(straight):
                // When the robot if facing straight
                while(SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar){
                    lightLED();
                    goStraight();
                }
                if (positionNumber() == 0){
                	lightLED();
                	connection();
                	position = started;
              	}
              	else{
                	lightLED();
                	findPosition();
              }
                break;
            case(right):
                // Turn the wheels to the right
                //button_pushed = false;
                lightLED();
                goRight();
                findPosition();
                break;

            case(left):
                // Turn the wheels to the left
                //button_pushed = false;
                lightLED();
                goLeft();
                findPosition();
                break;

            case(wall):
                // Turn the wheels to the left
                //button_pushed = false;
                lightLED();
                goLeft();
                findPosition();
                break;
            // End of switch
            case(tooClose):
                //button_pushed = false;
                lightLED();
                goBack();
                findPosition();
                break;

        }
    }
}
