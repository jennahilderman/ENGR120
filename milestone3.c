#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraFrontL,    sensorReflection)
#pragma config(Sensor, in2,    infraBack,      sensorReflection)
#pragma config(Sensor, in3,    infraFrontR,    sensorReflection)
#pragma config(Sensor, dgtl4,  button, sensorTouch)
#pragma config(Sensor, dgtl5,  batInput,       sensorSONAR_cm)
#pragma config(Sensor, dgtl1,  tooFarLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  justRightLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  tooCloseLED,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const				int retreat = -50;
const       int rotate = 150;
const       int movingSpeed = 30;
const				int turningSpeed = 20;
const				int openClawSpeed = 30;
const				int openClawDistance = 40;
const       int tooFar = -1;
const       int justRight = 7;
const				int IR_SENSOR_THRESHOLD = 830;
const       int LIGHT_OFF = 0;
const       int LIGHT_ON = 1;

bool    button_pushed;

enum t_position {
    straight = 0,
    left,
    right,
    wall,
    tooClose,
    stopped
};

enum t_claw{
	neutral = 0,
	open,
	close,
	backup,
};



// Initialize the enumerations
t_position position;
t_claw claw;



// Function to see if a button is pushed.
void monitorInput(){
    if(SensorValue(button) && !button_pushed){
        button_pushed = true;
    }
}

// Function finds the position of the robot
int findPosition(){
    if ((SensorValue[infraFrontR] <= (0.7*SensorValue[infraFrontL]) || SensorValue[infraFrontL] <= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        position = straight;
        return 0;
        }
    if ((SensorValue[infraFrontL] >= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){
        position = right;
        return 1;
    }
    if ((SensorValue[infraFrontR] >= (0.7*SensorValue[infraFrontL])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){
        position = left;
        return 2;
    }
    if (SensorValue[infraBack] < IR_SENSOR_THRESHOLD){
        position = left;
        return 2;
        }
    if (SensorValue[infraFrontR] > IR_SENSOR_THRESHOLD && SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && SensorValue[infraBack] > IR_SENSOR_THRESHOLD && SensorValue(batInput) == tooFar){
        position = wall;
        return 3;
    }
    position = straight;
    return 4;
}
int positionNumber(){
    if ((SensorValue[infraFrontR] <= (0.7*SensorValue[infraFrontL]) || SensorValue[infraFrontL] <= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){

        return 0;
        }
    if ((SensorValue[infraFrontL] >= (0.7*SensorValue[infraFrontR])) && SensorValue[infraFrontR] < IR_SENSOR_THRESHOLD){

        return 1;
    }
    if ((SensorValue[infraFrontR] >= (0.7*SensorValue[infraFrontL])) && SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){

        return 2;
    }
    if (SensorValue[infraBack] < IR_SENSOR_THRESHOLD){

        return 2;
        }
    if (SensorValue[infraFrontR] > IR_SENSOR_THRESHOLD && SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && SensorValue[infraBack] > IR_SENSOR_THRESHOLD && SensorValue(batInput) == tooFar){

        return 3;
    }

    return 4;
}

// Stopping the motor
void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

// Turning the motor on to go straight for over a meter
void goStraight(){
	resetMotorEncoder(speedMotorL);
	while(SensorValue(batInput) > justRight || SensorValue(batInput) == tooFar){
        motor[speedMotorR] = movingSpeed-6;
        motor[speedMotorL] = movingSpeed;

    }
    halt();
}

void goBack(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) >= retreat){
        motor[speedMotorR] = -movingSpeed+6;
        motor[speedMotorL] = -movingSpeed;
  }
  halt();
}

// A function that turns the robot to the left

void goLeft(){
	resetMotorEncoder(speedMotorL);
    while(positionNumber() != 0 || getMotorEncoder(speedMotorL) >= rotate){
	    motor[speedMotorR] = turningSpeed;
	    motor[speedMotorL] = -turningSpeed;
    }
  	halt();
}

// A function that turns the robot to the right
void goRight(){
	resetMotorEncoder(speedMotorL);
	while(positionNumber() != 0|| getMotorEncoder(speedMotorL) <= rotate){
		motor[speedMotorR] = -turningSpeed;
		motor[speedMotorL] = turningSpeed;
	}
  halt();
}

// A function that opens the claw
void drop(){
	resetMotorEncoder(clawMotor);
	button_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}


void connection(){
	while(true){
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				// If the straight button is pushed
				if ( button_pushed ){
					// Change to the open state
					claw = open;
				}
				// Break out of the switch statement.
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Clear flag to indicate button processed
				button_pushed = false;
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = backup;
				// Break out of the switch statement.
				break;
			case(backup):
				motor[clawMotor] = 0;
				goBack();
				claw = neutral;
				break;
		}
	}
}

void lightLED(){
    if(SensorValue(batInput) > justRight && positionNumber() == 0){
        SensorValue[tooFarLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooCloseLED] = LIGHT_OFF;
    }
    if(SensorValue(batInput) == justRight && positionNumber() == 0){
        SensorValue[justRightLED] = LIGHT_ON;
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
        connection();
    }
    if(SensorValue(batInput) < justRight && positionNumber() == 0){
        SensorValue[tooCloseLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
    if(positionNumber() != 0){
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }

}


task main()
{
    // Start
		button_pushed = false;
    position = stopped;
    while (true){
    		monitorInput();
        switch(position){
            // Start of switch
            case(stopped):
                // Stop the motor
                halt();
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
                // When the button is pushed switch state
                if ( button_pushed ) {
                    // If button pushed, change state
                    findPosition();
                    // Clear flag to indicate button processed.
                    button_pushed = false;
                }
                lightLED();
                break;

            case(straight):
                // When the robot if facing straight
                while(SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar){
                    lightLED();
                    goStraight();
                }
                lightLED();
                position = stopped;
                break;

            case(right):
                // Turn the wheels to the right
                button_pushed = false;
                lightLED();
                goRight();
                findPosition();
                break;

            case(left):
                // Turn the wheels to the left
                button_pushed = false;
                lightLED();
                goLeft();
                findPosition();
                break;

            case(wall):
                // Turn the wheels to the left
                button_pushed = false;
                lightLED();
                goLeft();
                findPosition();
                break;
            // End of switch
            case(tooClose):
                button_pushed = false;
                lightLED();
                goBack();
                findPosition();
                break;

        }
    }
}
