#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraFrontL,    sensorReflection)
#pragma config(Sensor, in2,    infraBack,      sensorReflection)
#pragma config(Sensor, in3,    infraFrontR,    sensorReflection)
#pragma config(Sensor, dgtl4,  button, sensorTouch)
#pragma config(Sensor, dgtl5,  batInput,       sensorSONAR_cm)
#pragma config(Sensor, dgtl1,  tooFarLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  justRightLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  tooCloseLED,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  movingI2C,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  clawI2C,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           speedMotorL,   tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           speedMotorR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Some important constants
const				int retreat = -50;
const       int rotate = 100;
const       int movingSpeed = 30;
const				int turningSpeed = 20;
const				int openClawSpeed = 30;
const				int openClawDistance = 40;
const       int tooFar = -1;
const       int justRight = 7;
const				int IR_SENSOR_THRESHOLD = 830;
const       int LIGHT_OFF = 0;
const       int LIGHT_ON = 1;
const				int wallDistance = 35;

//declaring button_pushed to be  boolean
bool    button_pushed;

// an enumeration for the position of the robot
enum t_position {
    straight = 0,
    found,
    backwards,
    wall,
    stopped,
    started
};

//an enumeration for the claw
enum t_claw{
	neutral = 0,
	open,
	close,
	backup,
};

// Initialize the enumerations
t_position position;
t_claw claw;
int number;

// Function to see if a button is pushed.
void monitorInput(){
    if(SensorValue(button) && !button_pushed){
        button_pushed = true;
    }
}

int findPosition(){
		if ( SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD ){
			position = found;
			return 0;
		}
		if ( SensorValue[infraBack] < IR_SENSOR_THRESHOLD ){
			position = backwards;
			return 1;
		}
		if ( SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraBack] < IR_SENSOR_THRESHOLD && SensorValue[batInput] <= wallDistance ){
			position = wall;
			return 2;
		}
		if ( SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && SensorValue[infraBack] < IR_SENSOR_THRESHOLD && (SensorValue[batInput] >= wallDistance || SensorValue[batInput] == tooFar)){
			position = straight;
			return 3;
		}
		return 4;
	}

void halt(){
    motor[speedMotorR] = 0;
    motor[speedMotorL] = 0;
}

void goBack(){
	resetMotorEncoder(speedMotorL);
	while(getMotorEncoder(speedMotorL) >= retreat){
        motor[speedMotorR] = movingSpeed-6;
        motor[speedMotorL] = -movingSpeed;
  }
  halt();
}

void drop(){
	resetMotorEncoder(clawMotor);
	button_pushed = false;
	while(abs(getMotorEncoder(clawMotor)) <= openClawDistance){
		motor[clawMotor] = -openClawSpeed;
	}
	claw = neutral;
}

void connection(){
	while(true){
		// Start of switch statement.
		switch (claw){
			// First case is the claw is still
			case(neutral):
				// Turn the motor off
				motor[clawMotor] = 0;
				// If the straight button is pushed
				if ( button_pushed ){
					// Change to the open state
					claw = open;
				}
				// Break out of the switch statement.
				break;
			// Seccond case is the claw is opening.
			case(open):
				// Clear flag to indicate button processed
				button_pushed = false;
				// Call the drop function to open the claw
				drop();
				// Change to the neutral state.
				claw = backup;
				// Break out of the switch statement.
				break;
			case(backup):
				// turn off the motor before backing up
				motor[clawMotor] = 0;
				wait1Msec(2000);
				// call the go back function to move backwards
				goBack();
				// set claw to neutral
				claw = neutral;
				// break out of the switch statement
				break;
		}
		//end of switch statement
	}
	//end of while loop
}

void lightLED(){
		//set number to be the position number
		number = findPosition();
		//Checks to see if the robot is facing the beacon but too far away
    if(SensorValue(batInput) > justRight && number == 0){
        SensorValue[tooFarLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooCloseLED] = LIGHT_OFF;
    }
    // Checks to see if the robot is facing the beacon and is the proper distance away
    else if(SensorValue(batInput) == justRight && number == 0){
        SensorValue[justRightLED] = LIGHT_ON;
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
    // Checks to see if the robot is facing the beacon and is too close to the beacon
    else if(SensorValue(batInput) < justRight && number == 0){
        SensorValue[tooCloseLED] = LIGHT_ON;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }
    // if none of the other
    else{
        SensorValue[tooCloseLED] = LIGHT_OFF;
        SensorValue[justRightLED] = LIGHT_OFF;
        SensorValue[tooFarLED] = LIGHT_OFF;
    }

}

// Turning the motor on to go straight until it his a wall of the beacon
void goStraight(){
	resetMotorEncoder(speedMotorL);
	while(SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar){
        motor[speedMotorR] = -movingSpeed+6;
        motor[speedMotorL] = movingSpeed;
    }
    halt();
}

void goLeft(){
		resetMotorEncoder(speedMotorL);
    while(findPosition() != 0 && getMotorEncoder(speedMotorL) >= -rotate){
	    motor[speedMotorR] = -turningSpeed;
	    motor[speedMotorL] = -turningSpeed;
    }
  	halt();
}

void goRight(){
	motor[speedMotorR] = turningSpeed;
	motor[speedMotorL] = turningSpeed;
  halt();
}



task main()
{
	    // Start
		button_pushed = false;
    position = started;
    while (true){
    		monitorInput();
        switch(position){
            // Start of switch
            case(started):
                // Stop the motor
                halt();
                // Reset the encoders
                resetMotorEncoder(clawMotor);
                resetMotorEncoder(speedMotorL);
                // When the button is pushed switch state
                if ( button_pushed ) {
                    // If button pushed, change state
                	resetMotorEncoder(speedMotorL);
                		while(SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD && getMotorEncoder(speedMotorL) < 400){
                			goRight();
                		}
                		halt();
                		position = stopped;
                		findPosition();
                    // Clear flag to indicate button processed.
                    //button_pushed = false;
                }
                lightLED();
                break;
                case(stopped):
            			halt();
                	// Reset the encoders
                	resetMotorEncoder(clawMotor);
                	resetMotorEncoder(speedMotorL);
                	lightLED();
                	findPosition();
                break;

                case(straight):
                // When the robot if facing straight
                	while(SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar){
                    lightLED();
                    goStraight();
                	}
                	findPosition();
                break;
                case(found):
            			// When the robot if facing straight
              		while(SensorValue(batInput) >= justRight || SensorValue(batInput) == tooFar){
                    lightLED();
                    goStraight();
              		}
              		if (SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD){
           	     		lightLED();
                		wait1Msec(2000);
    								connection();
    								button_pushed = false;
                		position = started;
              	}
              	if (SensorValue[infraFrontL] > IR_SENSOR_THRESHOLD){
              		while(SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && getMotorEncoder(speedMotorL) >= -50){
              			turnLeft();
              		}
              		while(SensorValue[infraFrontL] < IR_SENSOR_THRESHOLD && getMotorEncoder(speedMotorL) <= 50){
              			turnRight();
              		}
              		findPosition();
              	}
                break;
                case(wall):
                	// Turn the wheels to the left
                	//button_pushed = false;
                	lightLED();
                	goBack();
                	goLeft();
                	findPosition();
                break;

		}
	}
}
